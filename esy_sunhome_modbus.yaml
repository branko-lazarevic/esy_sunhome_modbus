substitutions:
  device_name: esy-sunhome-hm6
  friendly_name: "ESY Sunhome HM6"

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

# Enable logging
logger:
  level: DEBUG
  baud_rate: 0  # Disable UART logging since we're using UART for Modbus
  logs:
    modbus_controller: DEBUG
    modbus: DEBUG
    uart: DEBUG

# API, comment out if using MQTT
api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

# mqtt:
#   broker: !secret mqtt_host
#   username: !secret mqtt_username
#   password: !secret mqtt_password
  
captive_portal:

# Configure UART for RS485 communication
uart:
  id: modbus_uart
  tx_pin: GPIO2 
  rx_pin: GPIO1
  baud_rate: 9600
  parity: NONE
  stop_bits: 1

# Configure Modbus
modbus:
  id: mbus
  uart_id: modbus_uart
  # If your M5 Isolated RS485 is NOT auto-direction, uncomment and set a GPIO:
  # flow_control_pin: GPIO5

# Global variable for update interval
globals:
  - id: update_interval_ms
    type: int
    restore_value: yes
    initial_value: '15000'

modbus_controller:
  - id: sunhome
    modbus_id: mbus
    address: 0x01  # Modbus slave address
    setup_priority: -10
    update_interval: 5s # Default, will be overridden
    command_throttle: 10ms

text_sensor:
  - platform: template
    id: operating_mode
    name: "Operating Mode"
    icon: "mdi:battery"
    update_interval: never
    lambda: |-
      return {};

  - platform: template
    id: battery_mode
    name: "Battery Mode"
    icon: "mdi:battery"
    update_interval: never
    lambda: |-
      return {};
  
  # WiFi Info
  - platform: wifi_info
    ip_address:
      name: "${friendly_name} IP Address"
    ssid:
      name: "${friendly_name} SSID"

  # ESPHome Version
  - platform: version
    name: "${friendly_name} ESPHome Version"
    hide_timestamp: true

sensor:
  - platform: modbus_controller
    modbus_controller_id: sunhome
    id: scan_hold_modes
    name: "Scan HOLD 20-39"
    address: 20
    register_type: holding
    register_count: 20      # 20â€“39
    value_type: U_WORD
    skip_updates: 0
    lambda: |-
      static uint16_t last_vals[20];
      static bool init = false;

      const uint8_t interesting[] = {
        23, 24, 30, 32
      };

      auto is_interesting = [&](uint16_t reg) -> bool {
        for (auto addr : interesting) {
          if (reg == addr) return true;
        }
        return false;
      };

      int reg_count = data.size() / 2;
      if (reg_count > 20) reg_count = 20;

      for (int i = 0; i < reg_count; i++) {
        uint16_t word = (uint16_t(data[2*i]) << 8) | data[2*i + 1];
        uint16_t reg  = item->start_address + i;

        if (!is_interesting(reg)) {
          if (!init) last_vals[i] = word;
          continue;
        }

        if (!init || word != last_vals[i]) {
          ESP_LOGI("modbus_mode", "HOLD reg %u = %u (0x%04X)", reg, word, word);
          last_vals[i] = word;
        }
      }

      init = true;
      return x;

  # ============================================================
  # BATTERY REGISTERS (Input Registers)
  # ============================================================

  - platform: modbus_controller
    modbus_controller_id: sunhome
    internal: true
    id: battery_operating_mode
    name: "Battery Operating Mode"
    register_type: read
    address: 5
    value_type: U_WORD
    accuracy_decimals: 0
    on_value:
      then:
        - lambda: |-
            int mode = (int) x;
            std::string s;
            switch (mode) {
              case 1:  s = "Regular Mode"; break;
              case 3:  s = "Export Mode"; break;
              case 4:  s = "Import Mode"; break;
              case 5:  s = "Import Mode"; break;
              default: {
                char buf[32];
                snprintf(buf, sizeof(buf), "Unknown (%d)", mode);
                s = buf;
              }
            }
            id(operating_mode).publish_state(s.c_str());

  # Register 29 (Address 28) - Battery Mode Code
  # 0=Unknown, 1=Charging, 2=Charge Topping, 3=Unknown, 4=Full, 5=Discharging
  - platform: modbus_controller
    modbus_controller_id: sunhome
    internal: true
    id: battery_code
    name: "Battery Code"
    register_type: read
    address: 28
    value_type: U_WORD
    accuracy_decimals: 0
    on_value:
      then:
        - lambda: |-
            int mode = (int) x;
            std::string s;
            switch (mode) {
              case 0:  s = "Unknown"; break;
              case 1:  s = "Charging"; break;
              case 2:  s = "Charge Topping"; break;
              case 3:  s = "Unknown"; break;
              case 4:  s = "Full"; break;
              case 5:  s = "Discharging"; break;
              default: {
                char buf[32];
                snprintf(buf, sizeof(buf), "Unknown (%d)", mode);
                s = buf;
              }
            }
            id(battery_mode).publish_state(s.c_str());

  # Register 32 (Address 31) - Battery Power (Signed for charge/discharge)
  - platform: modbus_controller
    modbus_controller_id: sunhome
    id: battery_power
    name: "Battery Power"
    register_type: read
    address: 31
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    icon: "mdi:battery-charging"
    value_type: S_WORD
    filters:
      - lambda: |-
          if (isnan(id(battery_code).state)) {
            return x;
          }

          int mode = (int) id(battery_code).state;

          if (mode == 5) {
            return -x; 
          } else {
            return x;
          }

  # Register 33 (Address 32) - Battery State of Charge
  - platform: modbus_controller
    modbus_controller_id: sunhome
    id: battery_soc
    name: "Battery SOC"
    register_type: read
    address: 32
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    icon: "mdi:battery"
    value_type: U_WORD

  # ============================================================
  # SOLAR / PV REGISTERS (Input Registers)
  # ============================================================

  # Register 23 (Address 22) - PV1 Power
  - platform: modbus_controller
    modbus_controller_id: sunhome
    id: pv1_power
    name: "PV1 Power"
    register_type: read
    address: 22
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    icon: "mdi:solar-panel"
    value_type: U_WORD

  # Register 26 (Address 25) - PV2 Power
  - platform: modbus_controller
    modbus_controller_id: sunhome
    id: pv2_power
    name: "PV2 Power"
    register_type: read
    address: 25
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    icon: "mdi:solar-panel"
    value_type: U_WORD
    
  # ============================================================
  # GRID REGISTERS (Input Registers)
  # ============================================================

  # Register 40 (Address 39) - Grid Frequency
  - platform: modbus_controller
    modbus_controller_id: sunhome
    id: grid_frequency
    name: "Grid Frequency"
    register_type: read
    address: 39
    unit_of_measurement: "Hz"
    device_class: frequency
    state_class: measurement
    icon: "mdi:sine-wave"
    value_type: U_WORD
    filters:
      - multiply: 0.01
    accuracy_decimals: 2

  # Register 43 (Address 42) - Grid AC Voltage
  - platform: modbus_controller
    modbus_controller_id: sunhome
    id: grid_voltage
    name: "Grid AC Voltage"
    register_type: read
    address: 42
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    icon: "mdi:flash"
    value_type: U_WORD
    filters:
      - multiply: 0.1
    accuracy_decimals: 1

  # Register 50 (Address 49) - Grid Power (Signed: positive=import, negative=export)
  - platform: modbus_controller
    modbus_controller_id: sunhome
    id: grid_power
    name: "Grid Power"
    register_type: read
    address: 49
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    icon: "mdi:transmission-tower"
    value_type: S_WORD

  # Register 55 (Address 54) - Grid Frequency Alt
  - platform: modbus_controller
    modbus_controller_id: sunhome
    id: grid_frequency_alt
    name: "Grid Frequency Alt"
    register_type: read
    address: 54
    unit_of_measurement: "Hz"
    device_class: frequency
    state_class: measurement
    value_type: U_WORD
    filters:
      - multiply: 0.01
    accuracy_decimals: 2

  # ============================================================
  # LOAD REGISTERS (Input Registers)
  # ============================================================

  # Register 91 (Address 90) - Load Power
  - platform: modbus_controller
    modbus_controller_id: sunhome
    id: load_power
    name: "Load Power"
    register_type: read
    address: 90
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    icon: "mdi:home-lightning-bolt"
    value_type: U_WORD

  # ============================================================
  # INVERTER STATUS REGISTERS (Input Registers)
  # ============================================================

  # Register 58 (Address 57) - External PV AC Voltage
  - platform: modbus_controller
    modbus_controller_id: sunhome
    id: ext_pv_voltage
    name: "External PV AC Voltage"
    register_type: read
    address: 57
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    value_type: U_WORD
    filters:
      - multiply: 0.1
    accuracy_decimals: 1

  # Register 76 (Address 75) - Internal PV AC Voltage
  - platform: modbus_controller
    modbus_controller_id: sunhome
    id: int_pv_voltage
    name: "Internal PV AC Voltage"
    register_type: read
    address: 75
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    value_type: U_WORD
    filters:
      - multiply: 0.1
    accuracy_decimals: 1

  # ============================================================
  # HOLDING REGISTERS (Energy Counters)
  # ============================================================

  # Register 31 (Address 30) - Daily Power Generation
  - platform: modbus_controller
    modbus_controller_id: sunhome
    id: daily_generation
    name: "Daily Power Generation"
    register_type: holding
    address: 30
    unit_of_measurement: "kWh"
    icon: "mdi:counter"
    device_class: energy
    state_class: total_increasing
    value_type: U_WORD
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  # ============================================================
  # CALCULATED SENSORS
  # ============================================================

  # Total PV Power
  - platform: template
    name: "Total PV Power"
    id: total_pv_power
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    icon: "mdi:solar-power"
    lambda: |-
      return id(pv1_power).state + id(pv2_power).state;
    update_interval: 10s

  # Net Power Flow (positive = consuming from grid, negative = exporting)
  - platform: template
    name: "Net Power Flow"
    id: net_power_flow
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    icon: "mdi:transmission-tower-export"
    lambda: |-
      float pv = id(pv1_power).state + id(pv2_power).state;
      float battery = id(battery_power).state;
      float load = id(load_power).state;
      float grid = id(grid_power).state;
      return grid;  // Positive = import, Negative = export
    update_interval: 10s

  # Self-Consumption Percentage
  - platform: template
    name: "Self Consumption"
    id: self_consumption
    unit_of_measurement: "%"
    icon: "mdi:percent"
    lambda: |-
      float pv = id(pv1_power).state + id(pv2_power).state;
      float grid = id(grid_power).state;
      if (pv <= 0) return 0;
      float consumed = pv - (grid < 0 ? abs(grid) : 0);  // PV minus export
      return (consumed / pv) * 100.0;
    update_interval: 10s
    accuracy_decimals: 1

  # ============================================================
  # INTEGRATION SENSORS (Energy Tracking for Home Assistant)
  # ============================================================

  # PV1 Energy
  - platform: integration
    id: pv1_energy
    name: "PV1 Energy"
    sensor: pv1_power
    time_unit: h
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    icon: "mdi:solar-power"
    restore: true
    accuracy_decimals: 3
    filters:
      # Multiplication factor from W to kW is 0.001
      - multiply: 0.001

  # PV2 Energy
  - platform: integration
    id: pv2_energy
    name: "PV2 Energy"
    sensor: pv2_power
    time_unit: h
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    icon: "mdi:solar-power"
    restore: true
    accuracy_decimals: 3
    filters:
      # Multiplication factor from W to kW is 0.001
      - multiply: 0.001

  # Total PV Energy
  - platform: integration
    id: total_pv_energy
    name: "Total PV Energy"
    sensor: total_pv_power
    time_unit: h
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    icon: "mdi:solar-power"
    restore: true
    accuracy_decimals: 3
    filters:
      # Multiplication factor from W to kW is 0.001
      - multiply: 0.001

  # Load Energy Consumption
  - platform: integration
    id: load_energy
    name: "Load Energy"
    sensor: load_power
    time_unit: h
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    icon: "mdi:home-lightning-bolt"
    restore: true
    accuracy_decimals: 3
    filters:
      # Multiplication factor from W to kW is 0.001
      - multiply: 0.001

  - platform: template
    id: grid_charge_power
    name: "Grid Charge Power"
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    internal: true
    lambda: |-
      if (isnan(id(grid_power).state)) return NAN;
      float p = id(grid_power).state;
      return p > 0.0f ? p : 0.0f;  // only positive part

  # Power when discharging (>=0, magnitude of negative)
  - platform: template
    id: grid_discharge_power
    name: "Grid Discharge Power"
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    internal: true
    lambda: |-
      if (isnan(id(grid_power).state)) return NAN;
      float p = id(grid_power).state;
      return p < 0.0f ? -p : 0.0f; // flip sign of negative part

  # Grid Import Energy (only when positive)
  - platform: integration
    id: grid_import_energy
    name: "Grid Import Energy"
    sensor: grid_charge_power
    time_unit: h
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    icon: "mdi:transmission-tower-import"
    restore: true
    accuracy_decimals: 3
    filters:
      - lambda: return max(0.0f, -x);  # Only count negative (export), make positive
      - multiply:  0.001
          
  # Grid Export Energy (only when negative, converted to positive)
  - platform: integration
    id: grid_export_energy
    name: "Grid Export Energy"
    sensor: grid_discharge_power
    time_unit: h
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    icon: "mdi:transmission-tower-export"
    restore: true
    accuracy_decimals: 3
    filters:
      - lambda: return max(0.0f, x);  # Only count positive (import)
      - multiply: 0.001

  # Power when charging (>=0)
  - platform: template
    id: battery_charge_power
    name: "Battery Charge Power"
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    internal: true
    lambda: |-
      if (isnan(id(battery_power).state)) return NAN;
      float p = id(battery_power).state;
      return p > 0.0f ? p : 0.0f;  // only positive part

  # Power when discharging (>=0, magnitude of negative)
  - platform: template
    id: battery_discharge_power
    name: "Battery Discharge Power"
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    internal: true
    lambda: |-
      if (isnan(id(battery_power).state)) return NAN;
      float p = id(battery_power).state;
      return p < 0.0f ? -p : 0.0f; // flip sign of negative part

  # Battery Charge Energy (only when charging)
  - platform: integration
    id: battery_charge_energy
    name: "Battery Charge Energy"
    sensor: battery_charge_power
    time_unit: h
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    icon: "mdi:battery-charging"
    restore: true
    accuracy_decimals: 1
    filters:
      - multiply: 0.001

  # Battery Discharge Energy (only when discharging)
  - platform: integration
    id: battery_discharge_energy
    name: "Battery Discharge Energy"
    sensor: battery_discharge_power
    time_unit: h
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    icon: "mdi:battery-arrow-down"
    restore: true
    accuracy_decimals: 1
    filters:
      - multiply: 0.001
  
  - platform: uptime
    name: "${friendly_name} Uptime"
    icon: "mdi:clock-outline"

  # WiFi Signal
  - platform: wifi_signal
    name: "${friendly_name} WiFi Signal"
    update_interval: 60s

# ============================================================
# BUTTONS
# ============================================================

button:
  - platform: template
    name: "Update Now"
    icon: "mdi:refresh"
    on_press:
      - component.update: sunhome

  - platform: template
    name: "Clear Energy Counters"
    icon: "mdi:refresh"
    on_press:
      - lambda: |-
          id(pv1_energy).publish_state(0);
          id(pv2_energy).publish_state(0);
          id(total_pv_energy).publish_state(0);
          id(load_energy).publish_state(0);
          id(grid_import_energy).publish_state(0);
          id(grid_export_energy).publish_state(0);
          id(battery_charge_energy).publish_state(0);
          id(battery_discharge_energy).publish_state(0);

  - platform: restart
    name: "${friendly_name} Restart"
    icon: "mdi:restart"
